#include <stdio.h>
#include <string.h>
#include <openssl/aes.h>
#include <openssl/rand.h>
#include "aes_ctr.h"

struct ctr_state
{
    unsigned char ivec[16];
    unsigned int num;
    unsigned char ecount[16];
};

FILE *fp;
FILE *rp;
FILE *op;
size_t count;
char *buffer;
AES_KEY key;

int bytes_read, bytes_written;
unsigned char indata[AES_BLOCK_SIZE];
unsigned char outdata[AES_BLOCK_SIZE];
unsigned char ckey[] = "afifgantengbnget"; // It is 128bits though..
unsigned char iv[8] = {0};                 //This should be generated by RAND_Bytes I will take into    consideration your previous post
struct ctr_state state;

int init_ctr(struct ctr_state *state, const unsigned char iv[8]);
void encrypt(const char *inputFile, const char *outputFile);
void decrypt(const char *outputFile, const char *recoveredFile);

int main()
{
    int flag = 0;
    const char inputFile[] = "input.txt";
    const char outputFile[] = "output.txt";
    const char recoveredFile[] = "recovered.txt";
    printf("Keterangan :\n");
    printf("Masukkan angka 1 jika ingin encrypt file\n");
    printf("Masukkan angka 2 jika ingin decrypt file\n");
    printf("Masukkan angka 3 jika sudah selesai\n");
    while (flag != 3)
    {
        printf("Masukkan angka : ");
        scanf("%d", &flag);
        if (flag == 1)
        {
            encrypt(inputFile, outputFile);
            printf("File sudah berhasil ter-enkripsi\n");
        }
        else if (flag == 2)
        {
            decrypt(outputFile, recoveredFile);
            printf("File sudah berhasil ter-dekripsi\n");
        }
    }
    printf("FINISH\n");
    return 0;
}

int init_ctr(struct ctr_state *state, const unsigned char iv[8])
{
    state->num = 0;
    memset(state->ecount, 0, 16);
    memset(state->ivec + 8, 0, 8);
    memcpy(state->ivec, iv, 8);
}

void encrypt(const char *inputFile, const char *outputFile)
{
    //Opening files where text plain text is read and ciphertext stored
    fp = fopen(inputFile, "rb");
    op = fopen(outputFile, "wb");
    if (fp == NULL)
    {
        fputs("File error", stderr);
        exit(1);
    }
    if (op == NULL)
    {
        fputs("File error", stderr);
        exit(1);
    }

    //Initializing the encryption KEY
    AES_set_encrypt_key(ckey, 128, &key);

    //Encrypting Blocks of 16 bytes and writing the output.txt with ciphertext
    init_ctr(&state, iv); //Counter call
    while (1)
    {
        bytes_read = fread(indata, 1, AES_BLOCK_SIZE, fp);
        AES_ctr128_encrypt(indata, outdata, bytes_read, &key, state.ivec, state.ecount, &state.num);
        bytes_written = fwrite(outdata, 1, bytes_read, op);
        if (bytes_read < AES_BLOCK_SIZE)
            break;
    }

    fclose(fp);
    fclose(op);
    free(buffer);
}

void decrypt(const char *outputFile, const char *recoveredFile)
{
    //Opening files where text cipher text is read and the plaintext recovered
    rp = fopen(recoveredFile, "wb");
    op = fopen(outputFile, "rb");
    if (rp == NULL)
    {
        fputs("File error", stderr);
        exit(1);
    }
    if (op == NULL)
    {
        fputs("File error", stderr);
        exit(1);
    }

    //Initializing the encryption KEY
    AES_set_encrypt_key(ckey, 128, &key);

    //Encrypting Blocks of 16 bytes and writing the output.txt with ciphertext
    init_ctr(&state, iv); //Counter call
    while (1)
    {
        bytes_read = fread(indata, 1, AES_BLOCK_SIZE, op);
        AES_ctr128_encrypt(indata, outdata, bytes_read, &key, state.ivec, state.ecount, &state.num);
        bytes_written = fwrite(outdata, 1, bytes_read, rp);
        if (bytes_read < AES_BLOCK_SIZE)
            break;
    }
    fclose(rp);
    fclose(op);
    free(buffer);
}
